import os
#import biotite.structure.io as bsio
import torch
import esm
import argparse
import shutil
from datetime import datetime
#from esmfold_report import data_organization
import pandas as pd
import numpy as np

model = esm.pretrained.esmfold_v1()
model = model.eval().cuda()

def parse_args():
    parser = argparse.ArgumentParser(description='Protein sequence prediction', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--input_folder', type=str, help='Folder for storing sequence files')
    parser.add_argument('--output_folder', type=str, help='Folder for storing output files')
    parser.add_argument("--mpnn_report_path", type=str, default=None,
                        help="The path to mpnn_report.csv. If not entered, the default path will be used: {work_dir}/mpnn_report.csv")
    

    return parser.parse_args()

#读取fasta文件中的序列，输出序列列表
def extract_sequences(file_path):
    sequences = []
    with open(file_path, "r") as f:
        file_content = f.read()
    lines = file_content.strip().split('\n')
    i = 1
    while i < len(lines):
        sequence = lines[i]
        sequences.append(sequence)
        i += 2
    return sequences

#输入单序列，输出pdb字符串
def sequence_to_pdb(sequence):
    with torch.no_grad():
        output = model.infer(sequence)
    ptm = output['ptm'].item()
    #print('ptm:', ptm)
    plddt = np.mean(output['plddt'].cpu().numpy())
    #print('plddt:', plddt)
    # 3. 直接生成PDB格式的字符串
    pdb_string = model.output_to_pdb(output)[0]
    #print('pdb_string:', pdb_string)
    return pdb_string, ptm, plddt

#根据esmfold预测生成的文本生成pdb文件，可以被dssp识别
def generate_pdb_file(pdb_str,pdb_path):
    now = datetime.now()
    header = [
        "HEADER    GENERATED BY ESMFOLD              {:%d-%b-%y}".format(now)
    ]
    # 步骤1：将文本按换行符分割成行列表
    lines = pdb_str.split('\n')

    # 步骤2：过滤掉包含"PARENT"的行（列表推导式）
    filtered_lines = [line for line in lines if "PARENT" not in line]

    # 步骤3：将过滤后的行重新拼接成完整文本
    output_fix = '\n'.join(filtered_lines)

    with open(pdb_path, "w") as f:
        for line in header:
            f.write(line.ljust(80) + '\n')
        f.write(output_fix)
    return


#输入fasta文件，输出fasta文件中每条序列的预测结果（pdb文件）
def structure_prediction(file_path, output_folder):
    print('Now start structure prediction!')
    sequences = extract_sequences(file_path)
    print('file_path:', file_path)
    #print('file_path_sequence:', sequences)
    file_name = os.path.basename(file_path).rsplit('.')[0]
    folder = os.path.join(output_folder, file_name)
    print('folder:', folder)
    if not os.path.exists(folder):  ##新建文件夹
        os.makedirs(folder, exist_ok=True)

    for i in range(len(sequences)):
        sequence = sequences[i]
        output, ptm , plddt = sequence_to_pdb(sequence)
        #print('output:', output)
        print(f'{file_path}')
        print(f'The structure of sequence {i} has been generated.')
        out_path = os.path.join(output_folder, file_name, f'{file_name}_{i}.pdb')
        print('out_path:', out_path)
        generate_pdb_file(output, out_path)
    return sequences, folder

#批量预测
def structure_prediction_filter_all(input_folder, output_pdb_folder):
    files = os.listdir(input_folder)
    files = sorted(files, key=natural_sort_key)
    for file in files:
        file_path = os.path.join(input_folder, file)
        sequences, pdb_folder = structure_prediction(file_path, output_pdb_folder)
    return

def natural_sort_key(filename):
    """生成自然排序的key：将文件名拆分为字符串和数字部分，数字转整数"""
    parts = re.split(r'(\d+)', os.path.splitext(filename)[0])
    key = []
    for part in parts:
        if part.isdigit():
            key.append(int(part))
        else:
            key.append(part)
    return key

#读取mpnn_report.csv文件，生成序列字典
def read_mpnn_report(mpnn_report_path):
    """
    {
    "Dusp4_A_2": {
        "Dusp4_A_2_mpnn_0": "完整的sequence序列...",
        "Dusp4_A_2_mpnn_2": "完整的sequence序列...",
        "Dusp4_A_2_mpnn_3": "完整的sequence序列...",
        ...
        },
    "Dusp4_A_8": {
        "Dusp4_A_8_mpnn_0": "完整的sequence序列...",
        "Dusp4_A_8_mpnn_1": "完整的sequence序列...",
        "Dusp4_A_8_mpnn_2": "完整的sequence序列...",
         ...
        }
    }

    """
    df = pd.read_csv(mpnn_report_path)
    # 筛选whether_pass为True的行
    filtered_df = df[df['whether_pass'] == True].copy()

    # 构建结果字典（保持原始顺序）
    result_dict = {}
    for backbone in filtered_df['backbone'].unique():
        backbone_data = filtered_df[filtered_df['backbone'] == backbone]
        inner_dict = {row['index']: row['sequence'] for _, row in backbone_data.iterrows()}
        result_dict[backbone] = inner_dict
    return result_dict

def mpnn_report_to_structure_prediction(mpnn_report_path, output_pdb_folder):
    ptm_l = []
    plddt_l = []
    result_dict = read_mpnn_report(mpnn_report_path)
    print('Now start structure prediction!')
    for backbone, value in result_dict.items():
        backbone_folder = os.path.join(output_pdb_folder, backbone)
        if not os.path.exists(backbone_folder):
            os.makedirs(backbone_folder, exist_ok=True)
        for index, seq in value.items():
            output, ptm , plddt = sequence_to_pdb(seq)
            ptm_l.append(ptm)
            plddt_l.append(plddt)
            pdb_path = f'{backbone_folder}/{index}.pdb'
            print(f'{pdb_path}')
            print(f'The structure of sequence {index} has been generated.')
            generate_pdb_file(
                pdb_str=output,
                pdb_path=pdb_path
            )
    return ptm_l, plddt_l

def esmfold_report_csv(mpnn_report_path, esmfold_report_path, ptm_l, plddt_l):
    df_original = pd.read_csv(mpnn_report_path)
    #  根据whether_pass列筛选出为TRUE的行
    df_filtered = df_original[df_original['whether_pass'] == True].copy()
    df_filtered.drop(columns=['whether_pass'], axis=1, inplace=True)
    df_renamed = df_filtered.rename(
        columns={
            'ss8': 'rfdiffusion_ss8',  # 旧列名→新列名
            'ss3': 'rfdiffusion_ss3'
        }
    )
    #  在DataFrame最后添加新列
    df_final = df_renamed.copy()
    df_final['ptm_score'] = ptm_l  # 新增ptm_score列
    df_final['plddt_score'] = plddt_l  # 新增plddt_score列

    # 5. 保存为新的CSV文件
    df_final.to_csv(esmfold_report_path)
    return


def main():
    args = parse_args()
    input_folder = os.path.expanduser(args.input_folder)
    output_folder = os.path.expanduser(args.output_folder)
    #plddt_threshold = args.plddt_threshold
    #seq_range_str = args.design_seq
    output_pdb_folder = os.path.join(output_folder, 'structure_prediction_files')
    #output_filter_folder = os.path.join(output_folder, 'filter_files')
    if not os.path.exists(output_pdb_folder):  ##新建文件夹
        os.makedirs(output_pdb_folder, exist_ok=True)

    #structure_prediction_filter_all(
        #input_folder=input_folder,
        #output_pdb_folder=output_pdb_folder
    #)

    if args.mpnn_report_path is not None:
        mpnn_report_path = args.mpnn_report_path
    else:
        work_dir = output_folder.rsplit('/',1)[0]
        mpnn_report_path = os.path.join(work_dir, 'mpnn_report.csv')

    if os.path.exists(mpnn_report_path):
        ptm_l, plddt_l = mpnn_report_to_structure_prediction(mpnn_report_path, output_pdb_folder)
        work_dir = output_folder.rsplit('/', 1)[0]
        esmfold_report_path = os.path.join(work_dir, 'esmfold_report.csv')
        esmfold_report_csv(mpnn_report_path, esmfold_report_path, ptm_l, plddt_l)
    else:
        structure_prediction_filter_all(
            input_folder=input_folder,
            output_pdb_folder=output_pdb_folder
        )






if __name__ == '__main__':
    main()